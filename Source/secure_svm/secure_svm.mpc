import random

# SGD parameters
lr = 0.01
C = 4


def show_matrix(X):
    for i in range(len(X)):
        print_ln("%s", X[i].reveal())
    print_ln("----------------")


def interchange_rows(X, az, k):
    tmp = Array(len(X[az]), sfix)
    tmp.assign_all(0)
    tmp += X[az]

    for j in range(len(X[k])):
        X[az][j] = X[k][j]

    for j in range(len(X[k])):
        X[k][j] = tmp[j]

    return X


def shuffle_matrix(X, y):
    n = len(X)
    for k in range(n - 1, 0, -1):
        az = random.randint(0, k)

        X = interchange_rows(X, az, k)
        y = interchange_rows(y, az, k)

    return X, y


def negative(X):
    neg_X = Matrix(len(X), len(X[0]), sfix)
    for i in range(len(X)):
        for j in range(len(X[0])):
            neg_X[i][j] = X[i][j] * sfix(-1)
    return neg_X


def fit(X, y, epochs=100):
    '''
    Method for SVM fitting
    '''
    # Number of columns in data
    m = len(X[0]) - 1

    # Weight initialization
    W = Matrix(m + 1, 1, sfix)
    for i in range(m + 1):
        W[i][0] = sfix(random.random())

    for epoch in range(epochs):
        X, y = shuffle_matrix(X, y)
        grads = compute_grads(X, y, W)
        lr_times_grads = Matrix(m + 1, 1, sfix)
        for i in range(m + 1):
            lr_times_grads[i][0] = lr * grads[i][0]
        
        W = W + negative(lr_times_grads)

    return W


def compute_grads(X, y, W):
    '''
    Method for loss gradient computation
    '''
    grads = Matrix(len(W), 1, sfix)
    for i in range(len(W)):
        grads[i][0] = sfix(0)

    # Create ones vector
    ones = Matrix(len(y), 1, sfix)
    for i in range(len(y)):
        ones[i][0] = sfix(1.0)

    distance = ones + negative(y.schur(X * W))
    
    @for_range(len(distance))
    def _(i):
        @if_e((distance[i][0] <= 0).reveal())
        def _():
            @for_range(len(W))
            def _(j):
                grads[j][0] += W[j][0]
        @else_
        def _():
            mult_Xi = Matrix(len(X[i]), 1, sfix)
            for j in range(len(X[i])):
                mult_Xi[j][0] = C * y[i][0] * X[i][j]
            neg_mult_Xi = negative(mult_Xi)

            @for_range(len(W))
            def _(j):
                grads[j][0] += W[j][0] + neg_mult_Xi[j][0]

    # Division
    n_sfix = sfix(len(X))

    for i in range(len(grads)):
        grads[i][0] = grads[i][0] / n_sfix

    return grads

# Number of parties
n_parties = 2

# Number of rows for each party
n_party_0 = 3
n_party_1 = 2

n_rows = n_party_0 + n_party_1
n_columns = 2

# Matrix with data
X = Matrix(n_rows, n_columns + 1, sfix)

# Complete matrix data construction
@for_range(n_party_0)
def _(row):
    for column in range(n_columns):
        X[row][column] = sfix.get_input_from(0)
    X[row][n_columns] = sfix(1.0)

@for_range(n_party_1)
def _(row):
    for column in range(n_columns):
        X[row + n_party_0][column] = sfix.get_input_from(1)
    X[row + n_party_0][n_columns] = sfix(1.0)

# Response vector
y = Matrix(n_rows, 1, sfix)

# Response variable construction
@for_range(n_party_0)
def _(row):
    y[row][0] = sfix.get_input_from(0)

@for_range(n_party_1)
def _(row):
    y[row + n_party_0][0] = sfix.get_input_from(1)

W_results = fit(X, y, epochs=20)

print_ln("Weights:")
show_matrix(W_results)