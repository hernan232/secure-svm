import random


sfix.set_precision(32, 64)


# SGD parameters
C = 4
tolerance = 1e-3
eps = 1e-5
kernel_type = "linear"


def show_matrix(X):
    for i in range(len(X)):
        print_ln("%s", X[i].reveal())
    print_ln("----------------")


def negative(X):
    neg_X = Matrix(len(X), len(X[0]), sfix)
    for i in range(len(X)):
        for j in range(len(X[0])):
            neg_X[i][j] = X[i][j] * sfix(-1)
    return neg_X


def fit(X, y, max_passes):
    n = len(X)
    m = len(X[0])

    n_alloc = Array(1, cint)
    n_alloc[0] = cint(n)

    # Alphas initialization
    alphas = Matrix(n, 1, sfix)
    alphas.assign_all(0)

    # Intercept initialization
    b = Array(1, sfix)
    b[0] = 0

    W = Matrix(m, 1, sfix)
    W.assign_all(0)

    passes = 0
    while passes < max_passes:
        num_changed = 0

        i = Array(1, cint)
        i[0] = 0
        @while_do(lambda x: x < n, regint(0))
        def _(_):
            # Break variable
            break_var = Array(1, cint)
            break_var[0] = 0

            Xi = X[i[0]]
            Ei = Array(1, sfix)
            
            # Ei computation
            @for_range(len(X[0]))
            def _(k):
                Ei[0] += Xi[k] * W[k]
            Ei[0] += b - y[i[0]][0]

            yi = y[i[0]][0]
            alpha_i = alphas[i][0]

            ri = Ei * yi

            # Computes the condition (ri < -tolerance and alpha_i < C) or (ri > tolerance and alpha_i > 0) in a secret way
            condition_le_tol = ri < -tolerance
            condition_le_alpha = alpha_i < C
            condition_ge_tol = ri > tolerance
            condition_ge_alpha = alpha_i > 0

            le_and = condition_le_tol.bit_and(condition_le_alpha)
            ge_and = condition_ge_tol.bit_and(condition_ge_alpha)

            complete_condition = (le_and.bit_not().bit_and(ge_and.bit_not)).bit_not()

            @if_(complete_condition.reveal())
            def _():
                j = Array(1, cint)
                j[0] = get_index_heuristic(i[0])
                Xj = X[j[0]]
                Ej = Array(1, sfix)

                # Ei computation
                @for_range(len(X[0]))
                def _(k):
                    Ej[0] += Xj[k] * W[k][0]
                Ej[0] += b - y[j[0]][0]

                yj = y[j[0]][0]

                alpha_i_old = alphas[i[0]][0]
                alpha_j_old = alphas[j[0]][0]

                L = Array(1, sfix)
                H = Array(1, sfix)

                @if_e((yi != yj).reveal())
                def _():
                    L[0] = max(0, alphas[j[0]][0] - alphas[i[0]][0])
                    H[0] = min(C, C + alphas[j[0]][0] - alphas[i[0]][0])
                @else_
                def _():
                    L[0] = max(0, alphas[j[0]][0] + alphas[i[0]][0] - C)
                    H[0] = min(C, alphas[j[0]][0] + alphas[i[0]][0])

                @if_((L[0] == H[0]).reveal())
                def _():
                    # Continue
                    i[0] += 1
                    break_var[0] = 1

                kii = Array(1, sfix)
                kij = Array(1, sfix)
                kjj = Array(1, sfix)

                eta = Array(1, sfix)

                @if_(break_var[0].bit_not())
                def _():
                    kii[0] = kernel(X[i[0]], X[i[0]])
                    kij[0] = kernel(X[i[0]], X[j[0]])
                    kjj[0] = kernel(X[j[0]], X[j[0]])

                    eta[0] = 2 * kij[0] - kii[0] - kjj[0]

                    @if_((eta[0] > 0).reveal())
                    def _():
                        i[0] += 1
                        break_var[0] = 1

                alpha_j_new = Array(1, sfix)
                @if_(break_var[0].bit_not())
                def _():
                    alpha_j_new[0] = alphas[j[0]][0] - yj * (Ei[0] - Ej[0]) / eta[0]

                     # Alpha2 new clipped
                    @if_((alpha_j_new[0] < L[0]).reveal())
                    def _():
                        alpha_j_new[0] = L[0]
                    @if_((alpha_j_new[0] > H[0]).reveal())
                    def _():
                        alpha_j_new[0] = H[0]

                    abs_alphas = abs(alpha_j_new[0] - alphas[j[0]][0])
                    @if_((abs_alphas < eps).reveal())
                    def _():
                        i[0] += 1
                        break_var[0] = 1
                
                alpha_i_new = Array(1, sfix)
                @if_(break_var[0].bit_not())
                def _():
                    s = y[i[0]][0] * y[j[0]][0]
                    alpha_i_new[0] = alphas[i[0]][0] + s * (alphas[j[0]][0] - alpha_j_new[0])

                    b1 = Array(1, sfix)
                    b2 = Array(1, sfix)
                    b1[0] = b[0] - Ei[0] - y[i[0]][0] * (alpha_i_new[0] - alphas[i[0]][0]) * kii[0] - y[j[0]][0] * (alpha_j_new[0] - alphas[j[0]][0]) * kij[0]
                    b2[0] = b[0] - Ej[0] - y[i[0]][0] * (alpha_i_new[0] - alphas[i[0]][0]) * kij[0] - y[j[0]][0] * (alpha_j_new[0] - alphas[j[0]][0]) * kjj[0]
                    
                    alpha_i_condition = (alpha_i_new[0] > 0) * (alpha_i_new[0] < C)
                    @if_(alpha_i_condition.reveal())
                    def _():
                        b[0] = b1[0]

                    alpha_j_condition = (alpha_j_new[0] > 0) * (alpha_j_new[0] < C)
                    @if_e()
                    def _():
                        b[0] = b2[0]
                    @else_
                    def _():
                        b[0] = (b1[0] + b2[0]) / 2.

                    alphas[i[0]][0] = alpha_i_new[0]
                    alphas[j[0]][0] = alpha_j_new[0]

                    # Weight update
                    @for_range(len(X[0]))
                    def _(k):
                        W[k][0] = 0
                        @for_range(n_alloc[0])
                        def _(m):
                            W[k][0] += X[m][k] * y[m][0] * alphas[m][0]

                    i[0] += 1
            
            return i[0]


def predict(X, W, b):
    b_array = Matrix(len(X), 1, sfix)
    b_array.assign_all(b)

    predictions = Array(len(X), sfix)
    evaluation = X * W + b_array

    for i in range(len(X)):
        @if_e((evaluation[i][0] > 0).reveal())
        def _():            
            predictions[i] = 1
        @else_
        def _():
            predictions[i] = -1
    
    return predictions    


def get_index_heuristic(j, n_rows):
    i_alloc = Array(1, cint)
    n_rows_alloc = Array(1, cint)
    n_rows_alloc[0] = cint(n_rows)

    i[0] = cint(random.randint(0, n_rows))
    @while_do(lambda x: x == j, regint(0))
    def _(_):
        i[0] = cint(random.randint(0, n_rows_alloc[0]))
        return i[0]

    return i[0]
    

def score(X, y, W, b):
    predictions = predict(X, W, b)
    sum_eq = Array(1, sfix)
    for i in range(len(X)):
        @if_((predictions[i] == y[i][0]).reveal())
        def _():
            sum_eq[0] += 1
    
    return sum_eq[0] / len(X)


if __name__ == "__main__":
    # Number of parties
    n_parties = 2

    # Number of rows for each party
    n_party_0 = 20
    n_party_1 = 25
    n_party_2 = 5

    n_rows = n_party_0 + n_party_1 + n_party_2
    n_columns = 2

    # Matrix with data
    X = Matrix(n_rows, n_columns, sfix)

    # Complete matrix data construction
    @for_range_opt(n_party_0)
    def _(row):
        for column in range(n_columns):
            X[row][column] = sfix.get_input_from(0)

    @for_range_opt(n_party_1)
    def _(row):
        for column in range(n_columns):
            X[row + n_party_0][column] = sfix.get_input_from(1)

    @for_range_opt(n_party_2)
    def _(row):
        for column in range(n_columns):
            X[row + n_party_0 + n_party_1][column] = sfix.get_input_from(2)

    # Response vector
    y = Matrix(n_rows, 1, sfix)

    # Response variable construction
    for row in range(n_party_0):
        y[row][0] = sfix.get_input_from(0)

    for row in range(n_party_1):
        y[row + n_party_0][0] = sfix.get_input_from(1)

    for row in range(n_party_2):
        y[row + n_party_0 + n_party_1][0] = sfix.get_input_from(2)

    W, b = fit(X, y, epochs=20)

    print_ln("Weights:")
    show_matrix(W)
    print_ln(b.reveal())

    print_ln("Accuracy:")
    accuracy = score(X, y, W)
    print_ln("%s", accuracy.reveal())


